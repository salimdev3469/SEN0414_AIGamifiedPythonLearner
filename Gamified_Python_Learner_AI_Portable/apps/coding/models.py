from django.db import models
from django.conf import settings
from apps.learning.models import Lesson


class Exercise(models.Model):
    """
    Coding exercise for a specific lesson.
    Generated by Gemini AI based on lesson content.
    """
    DIFFICULTY_CHOICES = [
        ('easy', 'Easy'),
        ('medium', 'Medium'),
        ('hard', 'Hard'),
    ]
    
    lesson = models.ForeignKey(Lesson, on_delete=models.CASCADE, related_name='exercises')
    title = models.CharField(max_length=255)
    description = models.TextField(help_text="Problem description (Markdown supported)")
    difficulty = models.CharField(max_length=10, choices=DIFFICULTY_CHOICES, default='easy')
    xp_reward = models.IntegerField(default=50, help_text="XP awarded for solving this exercise")
    
    # Code-related fields
    starter_code = models.TextField(default="# Write your code here\n", 
                                   help_text="Initial code template for the user")
    solution_code = models.TextField(blank=True, help_text="Reference solution (hidden from users)")
    
    # Exercise details
    hints = models.JSONField(default=list, blank=True, help_text="List of hints (revealed one by one)")
    expected_approach = models.TextField(blank=True, help_text="Expected approach/algorithm description")
    
    # Ordering and visibility
    order = models.IntegerField(default=1)
    is_published = models.BooleanField(default=True)
    
    # Metadata
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        ordering = ['lesson', 'order']
        unique_together = ['lesson', 'order']
        
    def __str__(self):
        return f"{self.lesson.title} - {self.title}"
    
    def get_difficulty_display_emoji(self):
        """Return emoji for difficulty level"""
        emojis = {
            'easy': 'ðŸŸ¢',
            'medium': 'ðŸŸ¡',
            'hard': 'ðŸ”´'
        }
        return emojis.get(self.difficulty, 'âšª')
    
    def is_solved_by(self, user):
        """Check if user has successfully solved this exercise"""
        if not user.is_authenticated:
            return False
        return UserSubmission.objects.filter(
            user=user, 
            exercise=self,
            is_correct=True
        ).exists()
    
    def user_attempts(self, user):
        """Get number of attempts by user"""
        if not user.is_authenticated:
            return 0
        return UserSubmission.objects.filter(user=user, exercise=self).count()


class TestCase(models.Model):
    """
    Test cases for exercises.
    Generated by Gemini AI.
    """
    exercise = models.ForeignKey(Exercise, on_delete=models.CASCADE, related_name='test_cases')
    
    # Test data
    input_data = models.TextField(help_text="Test input (JSON format)")
    expected_output = models.TextField(help_text="Expected output")
    
    # Visibility
    is_hidden = models.BooleanField(default=False, help_text="Hidden test cases for challenge")
    
    # Ordering
    order = models.IntegerField(default=1)
    
    class Meta:
        ordering = ['exercise', 'order']
        
    def __str__(self):
        visibility = "Hidden" if self.is_hidden else "Visible"
        return f"{self.exercise.title} - Test {self.order} ({visibility})"


class UserSubmission(models.Model):
    """
    User's code submissions for exercises.
    Evaluated by Gemini AI.
    """
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='submissions')
    exercise = models.ForeignKey(Exercise, on_delete=models.CASCADE, related_name='submissions')
    
    # Submission data
    code = models.TextField(help_text="User's submitted code")
    
    # Evaluation results (from Gemini)
    is_correct = models.BooleanField(default=False)
    feedback = models.TextField(blank=True, help_text="Gemini's feedback on the code")
    suggestions = models.TextField(blank=True, help_text="Suggestions for improvement")
    error_message = models.TextField(blank=True, help_text="Error message if code failed")
    
    # Test results
    passed_tests = models.IntegerField(default=0)
    total_tests = models.IntegerField(default=0)
    
    # Performance
    execution_time = models.FloatField(null=True, blank=True, help_text="Execution time in seconds")
    
    # Metadata
    submitted_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        ordering = ['-submitted_at']
        
    def __str__(self):
        status = "âœ“ Correct" if self.is_correct else "âœ— Incorrect"
        return f"{self.user.username} - {self.exercise.title} - {status}"
    
    def test_pass_rate(self):
        """Calculate test pass rate percentage"""
        if self.total_tests == 0:
            return 0
        return int((self.passed_tests / self.total_tests) * 100)
